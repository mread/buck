/*
 * Copyright 2014-present Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License. You may obtain
 * a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations
 * under the License.
 */

package com.facebook.buck.android;

import com.facebook.buck.util.Escaper;
import com.facebook.buck.util.HumanReadableException;
import com.google.common.base.Preconditions;
import com.google.common.collect.ImmutableMap;

import java.util.Map;

/**
 * Utilities for generating a {@code BuildConfig.java} file for Android.
 */
public class BuildConfigs {

  /**
   * Name of the boolean global variable provided by the standard Android tools to indicate whether
   * an app was built in debug mode or not.
   */
  public static final String DEBUG_CONSTANT = "DEBUG";

  /**
   * Name of a Buck-specific global variable that indicates whether an app was built using
   * exopackage.
   */
  public static final String IS_EXO_CONSTANT = "IS_EXOPACKAGE";

  /** @see #getDefaultBuildConfigConstants() */
  private static final ImmutableMap<String, Object> DEFAULT_BUILD_CONFIG_CONSTANTS =
      ImmutableMap.<String, Object>of(
          // DEBUG is expected by the standard Android tools.
          DEBUG_CONSTANT, true,
          // IS_EXOPACKAGE is a value we use internally for checking whether exopackage is being
          // used.
          IS_EXO_CONSTANT, false);

  /** Utility class: do not instantiate. */
  private BuildConfigs() {}

  /**
   * Returns a map of constants (and constant values) that every {@code BuildConfig.java} should
   * declare. The default value of each constant may be overridden by the {@code userValues} passed
   * to {@link #generateBuildConfigDotJava(String, boolean, Map)} when generating a
   * {@code BuildConfig.java}.
   */
  public static ImmutableMap<String, Object> getDefaultBuildConfigConstants() {
    return DEFAULT_BUILD_CONFIG_CONSTANTS;
  }

  /**
   * Generates the source code for an Android {@code BuildConfig.java} file with the default set of
   * constants specified by {@link #getDefaultBuildConfigConstants()}.
   */
  public static String generateBuildConfigDotJava(String javaPackage) {
    return generateBuildConfigDotJava(
        javaPackage,
        /* useConstantExpressions */ false,
        ImmutableMap.<String, Object>of());
  }

  /**
   * Generates the source code for an Android {@code BuildConfig.java} file with constants
   * specified by {@code userValues}. The type of each constant is inferred from the type of the
   * value in the map.
   * <p>
   * The output will also contain a constant for every entry in the map returned by
   * {@code #getDefaultConfigVariables()}. The default constants will be listed first,
   * followed by any user-defined constants.
   * <p>
   * If a key in the {@code userValues} map matches one in the
   * {@link #getDefaultBuildConfigConstants()} map, the value in the {@code userValues} map will be
   * used.
   * @param javaPackage The package for the Java class generated by this method.
   * @param useConstantExpressions If {@code true}, the value for each static final field in the
   *     generated class will be declared as the literal value in the {@code userValues} map. The
   *     values of such fields can be inlined by {@code javac}.
   *     <p>
   *     If {@code false}, the value for each static final field in the generated class will be
   *     declared as a non-constant expression that is guaranteed to evaluate to the same value
   *     in the {@code userValues} map. This ensures that the generated {@code BuildConfig.java}
   *     can still be used in Robolectric tests, but does not run the risk of its values being
   *     inlined by {@code javac}. This is important if the generated {@code BuildConfig} class is
   *     going to be swapped out by a different implementation by {@link AndroidBinary}. See
   *     {@link AndroidBuildConfig} for details.
   * @param userValues represents the fields that should be declared in the generated
   *     {@code BuildConfig} class. Keys represent field names and values represent the values for
   *     those fields. The type of the field is inferred from the type of the value.
   *     <p>
   *     Although the values of the map are restricted to {@code Object}, in practice, all values
   *     must be one of: {@code Boolean}, {@code String}, {@code Integer}, {@code Long},
   *     {@code Double}, or {@code Float}.
   */
  public static String generateBuildConfigDotJava(
      String javaPackage,
      boolean useConstantExpressions,
      Map<String, Object> userValues) {
    Preconditions.checkNotNull(javaPackage);
    Preconditions.checkNotNull(userValues);

    // We use an ImmutableMap.Builder to ensure that entry order is predictable.
    ImmutableMap.Builder<String, Object> valuesBuilder = ImmutableMap.<String, Object>builder();
    // List all of the default values first.
    for (Map.Entry<String, Object> entry : DEFAULT_BUILD_CONFIG_CONSTANTS.entrySet()) {
      String key = entry.getKey();
      Object userValue = userValues.get(key);
      valuesBuilder.put(key, userValue != null ? userValue : entry.getValue());
    }
    // List all of the user values that have not already been declared.
    for (Map.Entry<String, Object> entry : userValues.entrySet()) {
      String key = entry.getKey();
      if (!DEFAULT_BUILD_CONFIG_CONSTANTS.containsKey(key)) {
        valuesBuilder.put(key, entry.getValue());
      }
    }
    Map<String, Object> values = valuesBuilder.build();

    StringBuilder builder = new StringBuilder();
    builder.append("package ").append(javaPackage).append(";\n");
    builder.append("public class BuildConfig {\n");
    builder.append("  private BuildConfig() {}\n");
    for (Map.Entry<String, Object> entry : values.entrySet()) {
      String name = entry.getKey();
      Object value = entry.getValue();
      String type, defaultValue;
      if (value instanceof String) {
        type = "String";
        String stringValue = (String) value;
        defaultValue = Escaper.escapeAsJavaString(stringValue);
        if (!useConstantExpressions) {
          defaultValue = "!Boolean.parseBoolean(null) ? " + defaultValue + " : null";
        }
      } else if (value instanceof Boolean) {
        type = "boolean";
        boolean booleanValue = ((Boolean) value).booleanValue();
        if (useConstantExpressions) {
          defaultValue = String.valueOf(booleanValue);
        } else {
          // A non-constant expression that evaluates to false.
          defaultValue = "Boolean.parseBoolean(null)";
          if (booleanValue) {
            defaultValue = "!" + defaultValue;
          }
        }
      } else if (value instanceof Integer) {
        type = "int";
        int intValue = ((Integer) value).intValue();
        defaultValue = String.valueOf(intValue);
        if (!useConstantExpressions) {
          defaultValue = "!Boolean.parseBoolean(null) ? " + defaultValue + " : 0";
        }
      } else if (value instanceof Long) {
        type = "long";
        long longValue = ((Long) value).longValue();
        defaultValue = String.valueOf(longValue) + "L";
        if (!useConstantExpressions) {
          defaultValue = "!Boolean.parseBoolean(null) ? " + defaultValue + " : 0L";
        }
      } else if (value instanceof Double || value instanceof Float) {
        type = "double";
        double doubleValue = ((Number) value).doubleValue();
        defaultValue = String.valueOf(doubleValue);
        if (!useConstantExpressions) {
          defaultValue = "!Boolean.parseBoolean(null) ? " + defaultValue + " : 0.";
        }
      } else {
        throw new HumanReadableException(
            "BuildConfig variable '%s' has value '%s', but must be one of {String,Boolean,Number}.",
            name,
            value);
      }
      builder.append(String.format(
          "  public static final %s %s = %s;\n",
          type,
          name,
          defaultValue));
    }
    builder.append("}\n");
    return builder.toString();
  }
}
